## 减少虚化带来的负担

## 避免装箱

当需要在期望使用堆对象的 情况下使用栈对象时，就会导致装箱。装箱会导致新的堆对象被分配出来，而且其寿命通常很短，因此会导致较多的GC操作，因此比较被大家讨厌。以下列出了一些导致装箱的情况，其中有些不太常为大家所知，还请注意。

在任何以引用类型的隐喻使用值类型的场景下，装箱都会被调用。大多数情况下，这些现象并非很隐秘，诸如：

```csharp
    object boxedInt = 1;
```
或是
```csharp
void BoxSample(object papam)
{
    // ...do something
}

void Main(string[] params)
{
    BoxSample(10)
}
```
这样。如果确定此处的装箱并非必须的，可以通过简单的方法去除这里的装箱操作——使用泛型。

然而有时装箱操作并非那么明显。考虑如下代码：
```csharp
public class BoxSample
    {
        public void SampleMethod()
        {
            PureStruct member = new PureStruct();
            member.ToString();

            GenericMethod(member);
        }

        public bool GenericMethod<T>(T argu)
        {
            return argu != null;
        }
    }

    public struct PureStruct
    {
        public int Field;
    }
```

它们当中两个方法产生如下的IL代码：
```msil
.method public hidebysig instance void
    SampleMethod() cil managed
  {
    .maxstack 5
    .locals init (
      [0] valuetype Assets.Scripts.PureStruct argu
    )

    // [13 7 - 13 41]
    IL_0000: ldloca.s     argu
    IL_0002: initobj      Assets.Scripts.PureStruct

    // [14 7 - 14 22]
    IL_0008: ldloc.0      // argu
    IL_0009: box          Assets.Scripts.PureStruct     // OUCH!!!
    IL_000e: callvirt     instance string [mscorlib]System.ValueType::ToString()
    IL_0013: pop          

    // [15 7 - 15 43]
    IL_0014: ldarg.0      // this
    IL_0015: ldloc.0      // argu
    IL_0016: call         instance bool Assets.Scripts.BoxSample::GenericMethod<valuetype Assets.Scripts.PureStruct>(!!0/*valuetype Assets.Scripts.PureStruct*/)
    IL_001b: pop          
    IL_001c: ret          

  } // end of method BoxSample::SampleMethod

  .method public hidebysig instance bool
    GenericMethod<T>(
      !!0/*T*/ argu
    ) cil managed
  {
    .maxstack 8

    // [20 7 - 20 36]
    IL_0000: ldarg.1      // argu
    IL_0001: box          !!0/*T*/  // OUCH!!!
    IL_0006: ldnull       
    IL_0007: ceq          
    IL_0009: ldc.i4.0     
    IL_000a: ceq          
    IL_000c: ret          

  } // end of method BoxSample::GenericMethod
```
____
注意！有两处产生了装箱！其中一处源于对我们的结构PureStruct调用来自object的方法，另一次则是在泛型方法里对其进行判空。因为ToString方法是属于Object类型的方法，而Object类型是一个引用类型，因此第一处装箱的位置方法调用暗喻了对象的引用身份；第二处则是因为值类型不可能为null（可空类型重写了==操作符，暂不在此讨论范围之内）。

对于第一种情况，我们重写PureStruct结构的ToString方法：
```csharp
    public struct PureStruct
    {
        public int Field;

        public override string ToString()
        {
            return "Maru 9";
        }
    }
```
再看看SampleMethod的IL代码：
```csharp.method
  public hidebysig instance void
    SampleMethod() cil managed
  {
    .maxstack 5
    .locals init (
      [0] valuetype Assets.Scripts.PureStruct argu
    )

    // [13 7 - 13 41]
    IL_0000: ldloca.s     argu
    IL_0002: initobj      Assets.Scripts.PureStruct

    // [14 7 - 14 22]
    IL_0008: ldloca.s     argu
    IL_000a: call         instance string Assets.Scripts.PureStruct::ToString()
    IL_000f: pop          

    // [15 7 - 15 43]
    IL_0010: ldarg.0      // this
    IL_0011: ldloc.0      // argu
    IL_0012: call         instance bool Assets.Scripts.BoxSample::GenericMethod<valuetype Assets.Scripts.PureStruct>(!!0/*valuetype Assets.Scripts.PureStruct*/)
    IL_0017: pop          
    IL_0018: ret          

  } // end of method BoxSample::SampleMethod
```
___
好的，装箱没有了——非但如此，ToString甚至不被认为是个虚函数了。毕竟值类型是没法继承的。

对于第二种情况，如有条件则直接指定泛型参数的约束：
```csharp
public bool GenericMethod<T>(T argu) where T : struct
```

现在你甚至不能对argu参数判空了 ~_~

## 切换编译器

## 集合
